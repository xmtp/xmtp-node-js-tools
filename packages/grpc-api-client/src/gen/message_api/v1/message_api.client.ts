// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "message_api/v1/message_api.proto" (package "xmtp.message_api.v1", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc"
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc"
import { MessageApi } from "./message_api.js"
import type {
  BatchQueryResponse,
  BatchQueryRequest,
  QueryResponse,
  QueryRequest,
  SubscribeAllRequest,
  Envelope,
  SubscribeRequest,
} from "./message_api.js"
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc"
import { stackIntercept } from "@protobuf-ts/runtime-rpc"
import type { PublishResponse, PublishRequest } from "./message_api.js"
import type { UnaryCall } from "@protobuf-ts/runtime-rpc"
import type { RpcOptions } from "@protobuf-ts/runtime-rpc"
/**
 * RPC
 *
 * @generated from protobuf service xmtp.message_api.v1.MessageApi
 */
export interface IMessageApiClient {
  /**
   * Publish messages to the network
   *
   * @generated from protobuf rpc: Publish(xmtp.message_api.v1.PublishRequest) returns (xmtp.message_api.v1.PublishResponse);
   */
  publish(
    input: PublishRequest,
    options?: RpcOptions,
  ): UnaryCall<PublishRequest, PublishResponse>
  /**
   * Subscribe to a stream of new envelopes matching a predicate
   *
   * @generated from protobuf rpc: Subscribe(xmtp.message_api.v1.SubscribeRequest) returns (stream xmtp.message_api.v1.Envelope);
   */
  subscribe(
    input: SubscribeRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SubscribeRequest, Envelope>
  /**
   * Subscribe to a stream of all messages
   *
   * @generated from protobuf rpc: SubscribeAll(xmtp.message_api.v1.SubscribeAllRequest) returns (stream xmtp.message_api.v1.Envelope);
   */
  subscribeAll(
    input: SubscribeAllRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SubscribeAllRequest, Envelope>
  /**
   * Query the store for messages
   *
   * @generated from protobuf rpc: Query(xmtp.message_api.v1.QueryRequest) returns (xmtp.message_api.v1.QueryResponse);
   */
  query(
    input: QueryRequest,
    options?: RpcOptions,
  ): UnaryCall<QueryRequest, QueryResponse>
  /**
   * BatchQuery containing a set of queries to be processed
   *
   * @generated from protobuf rpc: BatchQuery(xmtp.message_api.v1.BatchQueryRequest) returns (xmtp.message_api.v1.BatchQueryResponse);
   */
  batchQuery(
    input: BatchQueryRequest,
    options?: RpcOptions,
  ): UnaryCall<BatchQueryRequest, BatchQueryResponse>
}
/**
 * RPC
 *
 * @generated from protobuf service xmtp.message_api.v1.MessageApi
 */
export class MessageApiClient implements IMessageApiClient, ServiceInfo {
  typeName = MessageApi.typeName
  methods = MessageApi.methods
  options = MessageApi.options
  constructor(private readonly _transport: RpcTransport) {}
  /**
   * Publish messages to the network
   *
   * @generated from protobuf rpc: Publish(xmtp.message_api.v1.PublishRequest) returns (xmtp.message_api.v1.PublishResponse);
   */
  publish(
    input: PublishRequest,
    options?: RpcOptions,
  ): UnaryCall<PublishRequest, PublishResponse> {
    const method = this.methods[0]
    const opt = this._transport.mergeOptions(options)
    return stackIntercept<PublishRequest, PublishResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    )
  }

  /**
   * Subscribe to a stream of new envelopes matching a predicate
   *
   * @generated from protobuf rpc: Subscribe(xmtp.message_api.v1.SubscribeRequest) returns (stream xmtp.message_api.v1.Envelope);
   */
  subscribe(
    input: SubscribeRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SubscribeRequest, Envelope> {
    const method = this.methods[1]
    const opt = this._transport.mergeOptions(options)
    return stackIntercept<SubscribeRequest, Envelope>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    )
  }

  /**
   * Subscribe to a stream of all messages
   *
   * @generated from protobuf rpc: SubscribeAll(xmtp.message_api.v1.SubscribeAllRequest) returns (stream xmtp.message_api.v1.Envelope);
   */
  subscribeAll(
    input: SubscribeAllRequest,
    options?: RpcOptions,
  ): ServerStreamingCall<SubscribeAllRequest, Envelope> {
    const method = this.methods[2]
    const opt = this._transport.mergeOptions(options)
    return stackIntercept<SubscribeAllRequest, Envelope>(
      "serverStreaming",
      this._transport,
      method,
      opt,
      input,
    )
  }

  /**
   * Query the store for messages
   *
   * @generated from protobuf rpc: Query(xmtp.message_api.v1.QueryRequest) returns (xmtp.message_api.v1.QueryResponse);
   */
  query(
    input: QueryRequest,
    options?: RpcOptions,
  ): UnaryCall<QueryRequest, QueryResponse> {
    const method = this.methods[3]
    const opt = this._transport.mergeOptions(options)
    return stackIntercept<QueryRequest, QueryResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    )
  }

  /**
   * BatchQuery containing a set of queries to be processed
   *
   * @generated from protobuf rpc: BatchQuery(xmtp.message_api.v1.BatchQueryRequest) returns (xmtp.message_api.v1.BatchQueryResponse);
   */
  batchQuery(
    input: BatchQueryRequest,
    options?: RpcOptions,
  ): UnaryCall<BatchQueryRequest, BatchQueryResponse> {
    const method = this.methods[4]
    const opt = this._transport.mergeOptions(options)
    return stackIntercept<BatchQueryRequest, BatchQueryResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input,
    )
  }
}
