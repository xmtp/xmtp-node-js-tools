// @generated by protobuf-ts 2.9.1
// @generated from protobuf file "message_api/v1/message_api.proto" (package "xmtp.message_api.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc"
import type { BinaryWriteOptions } from "@protobuf-ts/runtime"
import type { IBinaryWriter } from "@protobuf-ts/runtime"
import { WireType } from "@protobuf-ts/runtime"
import type { BinaryReadOptions } from "@protobuf-ts/runtime"
import type { IBinaryReader } from "@protobuf-ts/runtime"
import { UnknownFieldHandler } from "@protobuf-ts/runtime"
import type { PartialMessage } from "@protobuf-ts/runtime"
import { reflectionMergePartial } from "@protobuf-ts/runtime"
import { MESSAGE_TYPE } from "@protobuf-ts/runtime"
import { MessageType } from "@protobuf-ts/runtime"
/**
 * This is based off of the go-waku Index type, but with the
 * receiverTime and pubsubTopic removed for simplicity.
 * Both removed fields are optional
 *
 * @generated from protobuf message xmtp.message_api.v1.IndexCursor
 */
export interface IndexCursor {
  /**
   * @generated from protobuf field: bytes digest = 1;
   */
  digest: Uint8Array
  /**
   * @generated from protobuf field: uint64 sender_time_ns = 2;
   */
  senderTimeNs: bigint
}
/**
 * Wrapper for potentially multiple types of cursor
 *
 * @generated from protobuf message xmtp.message_api.v1.Cursor
 */
export interface Cursor {
  /**
   * @generated from protobuf oneof: cursor
   */
  cursor:
    | {
        oneofKind: "index"
        /**
         * @generated from protobuf field: xmtp.message_api.v1.IndexCursor index = 1;
         */
        index: IndexCursor
      }
    | {
        oneofKind: undefined
      }
}
/**
 * This is based off of the go-waku PagingInfo struct, but with the direction
 * changed to our SortDirection enum format
 *
 * @generated from protobuf message xmtp.message_api.v1.PagingInfo
 */
export interface PagingInfo {
  /**
   * Note: this is a uint32, while go-waku's pageSize is a uint64
   *
   * @generated from protobuf field: uint32 limit = 1;
   */
  limit: number
  /**
   * @generated from protobuf field: xmtp.message_api.v1.Cursor cursor = 2;
   */
  cursor?: Cursor
  /**
   * @generated from protobuf field: xmtp.message_api.v1.SortDirection direction = 3;
   */
  direction: SortDirection
}
/**
 * Envelope encapsulates a message while in transit.
 *
 * @generated from protobuf message xmtp.message_api.v1.Envelope
 */
export interface Envelope {
  /**
   * The topic the message belongs to,
   * If the message includes the topic as well
   * it MUST be the same as the topic in the envelope.
   *
   * @generated from protobuf field: string content_topic = 1;
   */
  contentTopic: string
  /**
   * Message creation timestamp
   * If the message includes the timestamp as well
   * it MUST be equivalent to the timestamp in the envelope.
   *
   * @generated from protobuf field: uint64 timestamp_ns = 2;
   */
  timestampNs: bigint
  /**
   * @generated from protobuf field: bytes message = 3;
   */
  message: Uint8Array
}
/**
 * Publish
 *
 * @generated from protobuf message xmtp.message_api.v1.PublishRequest
 */
export interface PublishRequest {
  /**
   * @generated from protobuf field: repeated xmtp.message_api.v1.Envelope envelopes = 1;
   */
  envelopes: Envelope[]
}
/**
 * Empty message as a response for Publish
 *
 * @generated from protobuf message xmtp.message_api.v1.PublishResponse
 */
export interface PublishResponse {}
/**
 * Subscribe
 *
 * @generated from protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export interface SubscribeRequest {
  /**
   * @generated from protobuf field: repeated string content_topics = 1;
   */
  contentTopics: string[]
}
/**
 * SubscribeAll
 *
 * @generated from protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export interface SubscribeAllRequest {}
/**
 * Query
 *
 * @generated from protobuf message xmtp.message_api.v1.QueryRequest
 */
export interface QueryRequest {
  /**
   * @generated from protobuf field: repeated string content_topics = 1;
   */
  contentTopics: string[]
  /**
   * @generated from protobuf field: uint64 start_time_ns = 2;
   */
  startTimeNs: bigint
  /**
   * @generated from protobuf field: uint64 end_time_ns = 3;
   */
  endTimeNs: bigint
  /**
   * @generated from protobuf field: xmtp.message_api.v1.PagingInfo paging_info = 4;
   */
  pagingInfo?: PagingInfo
}
/**
 * The response, containing envelopes, for a query
 *
 * @generated from protobuf message xmtp.message_api.v1.QueryResponse
 */
export interface QueryResponse {
  /**
   * @generated from protobuf field: repeated xmtp.message_api.v1.Envelope envelopes = 1;
   */
  envelopes: Envelope[]
  /**
   * @generated from protobuf field: xmtp.message_api.v1.PagingInfo paging_info = 2;
   */
  pagingInfo?: PagingInfo
}
/**
 * BatchQuery
 *
 * @generated from protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export interface BatchQueryRequest {
  /**
   * @generated from protobuf field: repeated xmtp.message_api.v1.QueryRequest requests = 1;
   */
  requests: QueryRequest[]
}
/**
 * Response containing a list of QueryResponse messages
 *
 * @generated from protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export interface BatchQueryResponse {
  /**
   * @generated from protobuf field: repeated xmtp.message_api.v1.QueryResponse responses = 1;
   */
  responses: QueryResponse[]
}
/**
 * Sort direction
 *
 * @generated from protobuf enum xmtp.message_api.v1.SortDirection
 */
export enum SortDirection {
  /**
   * @generated from protobuf enum value: SORT_DIRECTION_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,
  /**
   * @generated from protobuf enum value: SORT_DIRECTION_ASCENDING = 1;
   */
  ASCENDING = 1,
  /**
   * @generated from protobuf enum value: SORT_DIRECTION_DESCENDING = 2;
   */
  DESCENDING = 2,
}
// @generated message type with reflection information, may provide speed optimized methods
class IndexCursor$Type extends MessageType<IndexCursor> {
  constructor() {
    super("xmtp.message_api.v1.IndexCursor", [
      { no: 1, name: "digest", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
      {
        no: 2,
        name: "sender_time_ns",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
    ])
  }
  create(value?: PartialMessage<IndexCursor>): IndexCursor {
    const message = { digest: new Uint8Array(0), senderTimeNs: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<IndexCursor>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: IndexCursor,
  ): IndexCursor {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* bytes digest */ 1:
          message.digest = reader.bytes()
          break
        case /* uint64 sender_time_ns */ 2:
          message.senderTimeNs = reader.uint64().toBigInt()
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: IndexCursor,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* bytes digest = 1; */
    if (message.digest.length)
      writer.tag(1, WireType.LengthDelimited).bytes(message.digest)
    /* uint64 sender_time_ns = 2; */
    if (message.senderTimeNs !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.senderTimeNs)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.IndexCursor
 */
export const IndexCursor = new IndexCursor$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Cursor$Type extends MessageType<Cursor> {
  constructor() {
    super("xmtp.message_api.v1.Cursor", [
      {
        no: 1,
        name: "index",
        kind: "message",
        oneof: "cursor",
        T: () => IndexCursor,
      },
    ])
  }
  create(value?: PartialMessage<Cursor>): Cursor {
    const message = { cursor: { oneofKind: undefined } }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<Cursor>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Cursor,
  ): Cursor {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* xmtp.message_api.v1.IndexCursor index */ 1:
          message.cursor = {
            oneofKind: "index",
            index: IndexCursor.internalBinaryRead(
              reader,
              reader.uint32(),
              options,
              (message.cursor as any).index,
            ),
          }
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Cursor,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* xmtp.message_api.v1.IndexCursor index = 1; */
    if (message.cursor.oneofKind === "index")
      IndexCursor.internalBinaryWrite(
        message.cursor.index,
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Cursor
 */
export const Cursor = new Cursor$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PagingInfo$Type extends MessageType<PagingInfo> {
  constructor() {
    super("xmtp.message_api.v1.PagingInfo", [
      { no: 1, name: "limit", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
      { no: 2, name: "cursor", kind: "message", T: () => Cursor },
      {
        no: 3,
        name: "direction",
        kind: "enum",
        T: () => [
          "xmtp.message_api.v1.SortDirection",
          SortDirection,
          "SORT_DIRECTION_",
        ],
      },
    ])
  }
  create(value?: PartialMessage<PagingInfo>): PagingInfo {
    const message = { limit: 0, direction: 0 }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<PagingInfo>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PagingInfo,
  ): PagingInfo {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* uint32 limit */ 1:
          message.limit = reader.uint32()
          break
        case /* xmtp.message_api.v1.Cursor cursor */ 2:
          message.cursor = Cursor.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.cursor,
          )
          break
        case /* xmtp.message_api.v1.SortDirection direction */ 3:
          message.direction = reader.int32()
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: PagingInfo,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* uint32 limit = 1; */
    if (message.limit !== 0)
      writer.tag(1, WireType.Varint).uint32(message.limit)
    /* xmtp.message_api.v1.Cursor cursor = 2; */
    if (message.cursor)
      Cursor.internalBinaryWrite(
        message.cursor,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* xmtp.message_api.v1.SortDirection direction = 3; */
    if (message.direction !== 0)
      writer.tag(3, WireType.Varint).int32(message.direction)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PagingInfo
 */
export const PagingInfo = new PagingInfo$Type()
// @generated message type with reflection information, may provide speed optimized methods
class Envelope$Type extends MessageType<Envelope> {
  constructor() {
    super("xmtp.message_api.v1.Envelope", [
      {
        no: 1,
        name: "content_topic",
        kind: "scalar",
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "timestamp_ns",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 3, name: "message", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
    ])
  }
  create(value?: PartialMessage<Envelope>): Envelope {
    const message = {
      contentTopic: "",
      timestampNs: 0n,
      message: new Uint8Array(0),
    }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<Envelope>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: Envelope,
  ): Envelope {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* string content_topic */ 1:
          message.contentTopic = reader.string()
          break
        case /* uint64 timestamp_ns */ 2:
          message.timestampNs = reader.uint64().toBigInt()
          break
        case /* bytes message */ 3:
          message.message = reader.bytes()
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: Envelope,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* string content_topic = 1; */
    if (message.contentTopic !== "")
      writer.tag(1, WireType.LengthDelimited).string(message.contentTopic)
    /* uint64 timestamp_ns = 2; */
    if (message.timestampNs !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.timestampNs)
    /* bytes message = 3; */
    if (message.message.length)
      writer.tag(3, WireType.LengthDelimited).bytes(message.message)
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.Envelope
 */
export const Envelope = new Envelope$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PublishRequest$Type extends MessageType<PublishRequest> {
  constructor() {
    super("xmtp.message_api.v1.PublishRequest", [
      {
        no: 1,
        name: "envelopes",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Envelope,
      },
    ])
  }
  create(value?: PartialMessage<PublishRequest>): PublishRequest {
    const message = { envelopes: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<PublishRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PublishRequest,
  ): PublishRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated xmtp.message_api.v1.Envelope envelopes */ 1:
          message.envelopes.push(
            Envelope.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: PublishRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated xmtp.message_api.v1.Envelope envelopes = 1; */
    for (let i = 0; i < message.envelopes.length; i++)
      Envelope.internalBinaryWrite(
        message.envelopes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishRequest
 */
export const PublishRequest = new PublishRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class PublishResponse$Type extends MessageType<PublishResponse> {
  constructor() {
    super("xmtp.message_api.v1.PublishResponse", [])
  }
  create(value?: PartialMessage<PublishResponse>): PublishResponse {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<PublishResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: PublishResponse,
  ): PublishResponse {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: PublishResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.PublishResponse
 */
export const PublishResponse = new PublishResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeRequest$Type extends MessageType<SubscribeRequest> {
  constructor() {
    super("xmtp.message_api.v1.SubscribeRequest", [
      {
        no: 1,
        name: "content_topics",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
    ])
  }
  create(value?: PartialMessage<SubscribeRequest>): SubscribeRequest {
    const message = { contentTopics: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<SubscribeRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SubscribeRequest,
  ): SubscribeRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated string content_topics */ 1:
          message.contentTopics.push(reader.string())
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: SubscribeRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string content_topics = 1; */
    for (let i = 0; i < message.contentTopics.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.contentTopics[i])
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeRequest
 */
export const SubscribeRequest = new SubscribeRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class SubscribeAllRequest$Type extends MessageType<SubscribeAllRequest> {
  constructor() {
    super("xmtp.message_api.v1.SubscribeAllRequest", [])
  }
  create(value?: PartialMessage<SubscribeAllRequest>): SubscribeAllRequest {
    const message = {}
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<SubscribeAllRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: SubscribeAllRequest,
  ): SubscribeAllRequest {
    return target ?? this.create()
  }
  internalBinaryWrite(
    message: SubscribeAllRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.SubscribeAllRequest
 */
export const SubscribeAllRequest = new SubscribeAllRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class QueryRequest$Type extends MessageType<QueryRequest> {
  constructor() {
    super("xmtp.message_api.v1.QueryRequest", [
      {
        no: 1,
        name: "content_topics",
        kind: "scalar",
        repeat: 2 /*RepeatType.UNPACKED*/,
        T: 9 /*ScalarType.STRING*/,
      },
      {
        no: 2,
        name: "start_time_ns",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      {
        no: 3,
        name: "end_time_ns",
        kind: "scalar",
        T: 4 /*ScalarType.UINT64*/,
        L: 0 /*LongType.BIGINT*/,
      },
      { no: 4, name: "paging_info", kind: "message", T: () => PagingInfo },
    ])
  }
  create(value?: PartialMessage<QueryRequest>): QueryRequest {
    const message = { contentTopics: [], startTimeNs: 0n, endTimeNs: 0n }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryRequest,
  ): QueryRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated string content_topics */ 1:
          message.contentTopics.push(reader.string())
          break
        case /* uint64 start_time_ns */ 2:
          message.startTimeNs = reader.uint64().toBigInt()
          break
        case /* uint64 end_time_ns */ 3:
          message.endTimeNs = reader.uint64().toBigInt()
          break
        case /* xmtp.message_api.v1.PagingInfo paging_info */ 4:
          message.pagingInfo = PagingInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagingInfo,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated string content_topics = 1; */
    for (let i = 0; i < message.contentTopics.length; i++)
      writer.tag(1, WireType.LengthDelimited).string(message.contentTopics[i])
    /* uint64 start_time_ns = 2; */
    if (message.startTimeNs !== 0n)
      writer.tag(2, WireType.Varint).uint64(message.startTimeNs)
    /* uint64 end_time_ns = 3; */
    if (message.endTimeNs !== 0n)
      writer.tag(3, WireType.Varint).uint64(message.endTimeNs)
    /* xmtp.message_api.v1.PagingInfo paging_info = 4; */
    if (message.pagingInfo)
      PagingInfo.internalBinaryWrite(
        message.pagingInfo,
        writer.tag(4, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryRequest
 */
export const QueryRequest = new QueryRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class QueryResponse$Type extends MessageType<QueryResponse> {
  constructor() {
    super("xmtp.message_api.v1.QueryResponse", [
      {
        no: 1,
        name: "envelopes",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => Envelope,
      },
      { no: 2, name: "paging_info", kind: "message", T: () => PagingInfo },
    ])
  }
  create(value?: PartialMessage<QueryResponse>): QueryResponse {
    const message = { envelopes: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<QueryResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: QueryResponse,
  ): QueryResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated xmtp.message_api.v1.Envelope envelopes */ 1:
          message.envelopes.push(
            Envelope.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        case /* xmtp.message_api.v1.PagingInfo paging_info */ 2:
          message.pagingInfo = PagingInfo.internalBinaryRead(
            reader,
            reader.uint32(),
            options,
            message.pagingInfo,
          )
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: QueryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated xmtp.message_api.v1.Envelope envelopes = 1; */
    for (let i = 0; i < message.envelopes.length; i++)
      Envelope.internalBinaryWrite(
        message.envelopes[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    /* xmtp.message_api.v1.PagingInfo paging_info = 2; */
    if (message.pagingInfo)
      PagingInfo.internalBinaryWrite(
        message.pagingInfo,
        writer.tag(2, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.QueryResponse
 */
export const QueryResponse = new QueryResponse$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BatchQueryRequest$Type extends MessageType<BatchQueryRequest> {
  constructor() {
    super("xmtp.message_api.v1.BatchQueryRequest", [
      {
        no: 1,
        name: "requests",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => QueryRequest,
      },
    ])
  }
  create(value?: PartialMessage<BatchQueryRequest>): BatchQueryRequest {
    const message = { requests: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<BatchQueryRequest>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BatchQueryRequest,
  ): BatchQueryRequest {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated xmtp.message_api.v1.QueryRequest requests */ 1:
          message.requests.push(
            QueryRequest.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: BatchQueryRequest,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated xmtp.message_api.v1.QueryRequest requests = 1; */
    for (let i = 0; i < message.requests.length; i++)
      QueryRequest.internalBinaryWrite(
        message.requests[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryRequest
 */
export const BatchQueryRequest = new BatchQueryRequest$Type()
// @generated message type with reflection information, may provide speed optimized methods
class BatchQueryResponse$Type extends MessageType<BatchQueryResponse> {
  constructor() {
    super("xmtp.message_api.v1.BatchQueryResponse", [
      {
        no: 1,
        name: "responses",
        kind: "message",
        repeat: 1 /*RepeatType.PACKED*/,
        T: () => QueryResponse,
      },
    ])
  }
  create(value?: PartialMessage<BatchQueryResponse>): BatchQueryResponse {
    const message = { responses: [] }
    globalThis.Object.defineProperty(message, MESSAGE_TYPE, {
      enumerable: false,
      value: this,
    })
    if (value !== undefined)
      reflectionMergePartial<BatchQueryResponse>(this, message, value)
    return message
  }
  internalBinaryRead(
    reader: IBinaryReader,
    length: number,
    options: BinaryReadOptions,
    target?: BatchQueryResponse,
  ): BatchQueryResponse {
    let message = target ?? this.create(),
      end = reader.pos + length
    while (reader.pos < end) {
      let [fieldNo, wireType] = reader.tag()
      switch (fieldNo) {
        case /* repeated xmtp.message_api.v1.QueryResponse responses */ 1:
          message.responses.push(
            QueryResponse.internalBinaryRead(reader, reader.uint32(), options),
          )
          break
        default:
          let u = options.readUnknownField
          if (u === "throw")
            throw new globalThis.Error(
              `Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`,
            )
          let d = reader.skip(wireType)
          if (u !== false)
            (u === true ? UnknownFieldHandler.onRead : u)(
              this.typeName,
              message,
              fieldNo,
              wireType,
              d,
            )
      }
    }
    return message
  }
  internalBinaryWrite(
    message: BatchQueryResponse,
    writer: IBinaryWriter,
    options: BinaryWriteOptions,
  ): IBinaryWriter {
    /* repeated xmtp.message_api.v1.QueryResponse responses = 1; */
    for (let i = 0; i < message.responses.length; i++)
      QueryResponse.internalBinaryWrite(
        message.responses[i],
        writer.tag(1, WireType.LengthDelimited).fork(),
        options,
      ).join()
    let u = options.writeUnknownFields
    if (u !== false)
      (u == true ? UnknownFieldHandler.onWrite : u)(
        this.typeName,
        message,
        writer,
      )
    return writer
  }
}
/**
 * @generated MessageType for protobuf message xmtp.message_api.v1.BatchQueryResponse
 */
export const BatchQueryResponse = new BatchQueryResponse$Type()
/**
 * @generated ServiceType for protobuf service xmtp.message_api.v1.MessageApi
 */
export const MessageApi = new ServiceType("xmtp.message_api.v1.MessageApi", [
  {
    name: "Publish",
    options: { "google.api.http": { post: "/message/v1/publish", body: "*" } },
    I: PublishRequest,
    O: PublishResponse,
  },
  {
    name: "Subscribe",
    serverStreaming: true,
    options: {
      "google.api.http": { post: "/message/v1/subscribe", body: "*" },
    },
    I: SubscribeRequest,
    O: Envelope,
  },
  {
    name: "Subscribe2",
    serverStreaming: true,
    clientStreaming: true,
    options: {},
    I: SubscribeRequest,
    O: Envelope,
  },
  {
    name: "SubscribeAll",
    serverStreaming: true,
    options: {
      "google.api.http": { post: "/message/v1/subscribe-all", body: "*" },
    },
    I: SubscribeAllRequest,
    O: Envelope,
  },
  {
    name: "Query",
    options: { "google.api.http": { post: "/message/v1/query", body: "*" } },
    I: QueryRequest,
    O: QueryResponse,
  },
  {
    name: "BatchQuery",
    options: {
      "google.api.http": { post: "/message/v1/batch-query", body: "*" },
    },
    I: BatchQueryRequest,
    O: BatchQueryResponse,
  },
])
